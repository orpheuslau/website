Here is a draft introduction for your full stack application:

My First Full Stack Application

I recently completed work on my first full stack web application to manage student assessments for teachers. The application features a modern React front end paired with a Node.js/Express backend and MongoDB database.

Authentication is handled securely using JSON Web Tokens (JWT). Passwords are hashed for protection before being saved to the database.

The application allows teachers to perform the following key functions:

Manage student profiles with CRUD operations
Create, edit and view assessment details using a CRUD interface
Export individual student assessment reports in PDF format
Export consolidated assessment results for an entire class in Excel for data analysis
View dynamic dashboards pulling data from the student and assessment collections
Search across students and assessments
User account setup and permission levels for administrators
Allow users to change their passwords
Overall this project allowed me to gain hands-on experience building a full-featured web application from front to back using modern technologies like React, Node.js and MongoDB. The various pages are designed to streamline common teacher workflows around managing student data and assessments.

Securing user authentication with JSON Web Tokens was another valuable learning experience. I'm very pleased with how the application turned out and look forward to continuing to expand my full stack development skills on future projects.

Here are some insights into how I implemented authentication using JSON Web Tokens (JWTs) for this project:

When a user signs up or signs in, I generate a JWT payload with the user ID and an expiry timestamp.

I sign the JWT using a secret key to cryptographically secure it. This secret is stored as an environment variable for security.

The signed JWT is returned to the client after log in as the access token to include in subsequent requests.

On the backend, I use the jsonwebtoken package to verify any incoming JWTs sent via the Authorization header.

I check the signature and expiration to validate the token is legit before attaching the user data to the request for authorization.

For secure access, I enforce authentication on sensitive routes using middleware to check for a valid JWT. Any unauthenticated requests are blocked.

When a user refreshes their page, the browser will automatically re-send the existing JWT, keeping them logged in across sessions.

If the token expires, the user has to log in again to get a new access token issued with a refreshed expiry time.

Overall, JWTs provide a simple yet secure way to handle user authentication in a stateless manner between the client and API. Let me know if any part of the implementation would be helpful for me to explain in more detail.

Here is an overview of how the Node.js/Express backend is implemented using the MVC pattern:

Model-View-Controller

The MVC pattern separates the application into three core components - the model, the view, and the controller. This structure promotes separation of concerns and modular code.

Model

The model components represent the data of the application and the business logic used to access and modify it.
For this application, models are defined using Mongoose to interface with the MongoDB database. Examples include the Student and Assessment models.
View

Views define the visual presentation layer of the UI.
Views are rendered on the server side using EJS templating Engine. Templates insert dynamic data into plain HTML.
Controller

Controllers handle HTTP requests and response logic. They coordinate between models and views.
Controller functions are defined in Express Router files. They call model methods, pass data to views, and return responses.
Routing

Express handles routing using a Router instance. Routes are defined for specific endpoints and HTTP methods.
Routes call controller functions which handle requests and responses for that endpoint.
Overall, this MVC pattern keeps code logical, modular and reusable. It allows the application to scale smoothly as new features are added via controller/route functions and additional model/view components.